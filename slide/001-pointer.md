# ポインター

江添亮

# 基礎

+ C++の多くの機能がポインターに依存している
+ ポインターの理解なくして他の機能の理解はできない


# 難しい理由

+ アドレス
+ 間接参照
+ 型システム
+ 文法


# 架空のマシン

以下のようなマシンを想定する

+ 8bitアドレス
+ フラットなアドレス空間
+ 255バイトのメモリ


# メモリ

+ 1バイト単位でアクセスできるメモリ
+ 255単位連続して並んでいる
+ 順序がある
+ 線形に並んでいる

# アドレス

+ 8bit
+ $2^8=256$ 通りの値を持つ
+ アドレス値1は最初の1バイトのメモリ
+ アドレス値2は次の1バイトのメモリ
+ ...
+ アドレス値255は最後の1バイトのメモリ

$$2^8$$

# メモリの指定方法

+ アドレス値で指定する
+ 全メモリの任意の1バイトを指定できる

# メモリのアクセス方法

+ 間接アクセス(indirection)

アドレス値を間接アクセスするとメモリの値が読み書きできる

# 変遷

+ void *
+ メンバーへのポインター
+ nullポインターリテラルとしての0
+ nullptr
+ 用語デリファレンスの廃止

# void *

+ 純粋なアドレス値を表現する型
+ 任意のポインター型から暗黙に変換できる
+ 任意のポインター型に明示的に変換できる
+ ポインター値をvoid *に変換して元の型のポインター値にもどすと同じポインター値になる
+ void *以前、mallocはchar *を返していた

# 例

~~~cpp
int * p1 = ... ;
void * p2 = p1 ;
int * p3 = static_cast<int *>(p2) ;
p1 == p3 ; // true
~~~

# メンバーへのポインター

+ メンバー関数へのポインター
+ データメンバーへのポインター

# 型

クラスCの型Tのメンバーへのポインター型

~~~cpp
T C::*
~~~

# ポインターを得る方法

クラスCのメンバー名memberへのポインターを得る

~~~cpp
&C::member
~~~

# 間接アクセス

クラスのオブジェクトobjectにメンバーへのポインターmem_ptrを使ってメンバーへの間接アクセス

~~~cpp
(object.*mem_ptr)
~~~

クラスへのポインターptrにメンバーへのポインターmem_ptrを使ってメンバーへの間接アクセス

~~~cpp
(ptr->*mem_ptr)
~~~

# データメンバーの例

~~~cpp
struct C { int member ; } ;
int C::* mem_ptr = &C::member ;
C object ;
// データメンバーへのアクセス
(object.*mem_ptr) = 123 ;
~~~

# メンバー関数の例

~~~cpp
struct C{ void member() {} } ;
void (C::* mem_ptr)() = &C::member ;
C object ;
// メンバー関数呼び出し
(object.*mem_ptr)() ;
~~~


# nullポインターリテラルとしての0

+ C言語ではNULLマクロによって置換されるトークン列がnullポインター値
+ C++が追加した
+ あくまでリテラル
+ nullポインター値は0とは限らない



# nullptr

+ C++11で追加されたnullポインターリテラル
+ 型はstd::nullptr_t

定義

~~~c++
using nullptr_t = decltype(nullptr) ;
~~~

# 用語

+ ポインターを経由した間接アクセス
+ indirection through a pointer

かつてはデリファレンス(dereference)という用語が使われていた

最近の規格改定で用語が統一された

# ブロックチェーン

今流行りの保障

時代遅れ、投機対象としての価値のみ

信頼性は保証してくれるが、それ自体には価値がない

フィアット通貨があるから価値がでているだけ

+ Proof of Work
+ Proof of Stake

# 期待

有益な計算力を保障すべき

純粋な演算は非効率的すぎる

ストレージという価値を提供する

+ Proof of Replication
+ Proof of Spacetime
